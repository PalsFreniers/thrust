addin "std"
addin "inc/op"

// language defines
define MEM_CAPACITY 1024 1024 * end // 1 MB

// memory spans constants
define SIM_STACK_CAP 1024 end
define OPS_CAP       1024 end

// memory layout
// putd buff(32) > sim stack count(8)
// sim stack(1024 * 8) > opcount(8) > ops(left)
alloc file-path        sizeof(str) end
alloc fd               sizeof(fd) end
alloc file-stat        sizeof(stat) end
alloc file-map         sizeof(str) end
alloc file-content     sizeof(str) end
alloc lineN            sizeof(size_t) end
alloc line             sizeof(str) end
alloc word             sizeof(str) end
alloc sim-stack-count  sizeof(size_t) end
alloc simulation-stack sizeof(u64) SIM_STACK_CAP * end
alloc ops-count        sizeof(size_t) end
alloc ops              sizeof(Op) OPS_CAP * end

// tokens
define TOK_WORD    0 end
define TOK_KEYWORD 1 end
define TOK_INT     2 end
define TOK_CHAR    3 end
define TOK_STR     4 end

// operations
// push operation
define OP_PUSH     0 end
define OP_STORESTR 1 end
// arithmetics
define OP_PLUS  2  end
define OP_MINUS 3  end
define OP_MUL   4  end
define OP_DIV   5  end
define OP_MOD   6  end
define OP_SHR   9  end
define OP_SHL   10 end
define OP_AND   11 end
define OP_OR    12 end
define OP_XOR   13 end
define OP_NOT   14 end
// conditions
define OP_EQUAL   15 end
define OP_GREATER 16 end
define OP_LESS    17 end
define OP_GEQ     18 end
define OP_LEQ     19 end
define OP_NEQ     20 end
// stack operations
define OP_DUP    21 end
define OP_SWAP   22 end
define OP_ROTATE 23 end
define OP_OVER   24 end
define OP_TRASH  25 end
define OP_DUMP   26 end
// keywords
define OP_IF     27 end
define OP_ELSE   28 end
define OP_ELIF   29 end
define OP_DURING 30 end
define OP_END    31 end
define OP_DEFINE 32 end
define OP_ADDIN  33 end
define OP_HERE   34 end
define OP_CALL0  35 end
define OP_CALL1  36 end
define OP_CALL2  37 end
define OP_CALL3  38 end
define OP_CALL4  39 end
define OP_CALL5  40 end
define OP_CALL6  41 end
// memory
define OP_MEM        42 end
define OP_MEMREAD    43 end
define OP_MEMREAD16  44 end
define OP_MEMREAD32  45 end
define OP_MEMREAD64  46 end
define OP_MEMWRITE   47 end
define OP_MEMWRITE16 48 end
define OP_MEMWRITE32 49 end
define OP_MEMWRITE64 50 end
// args
define OP_ARGC 51 end
define OP_ARGV 52 end
// type casting
define OP_CASTINT  53 end
define OP_CASTPTR  54 end
define OP_CASTBOOL 55 end

// "func" macros

fn push-op
        ops-count ,64 sizeof(Op) * ops +
        <--> Op.write()
        ops-count dup ,64 1 + <> .64
end

fn print-program
        0 during dup ops-count ,64 < go
                "--------------------\n" puts
                dup sizeof(Op) * ops + 
                Op.read() <>
                "    Type:    " puts dump
                "    operand: " puts dump
                1 + 
        end _
end

// simulation specific macros

fn sim-stack-push
        if sim-stack-count ,64 SIM_STACK_CAP >= go
                error "simulation stack overflow cannot push to full stack\n" eputs
        end
        simulation-stack sim-stack-count ,64 8 * + .64
        sim-stack-count dup ,64 1 + <> .64
end

fn sim-stack-pop
        if sim-stack-count ,64 0 = go
                error "simulation stack underflow cannot pop from empty stack\n" eputs
        end
        sim-stack-count dup ,64 1 -  <> .64
        simulation-stack sim-stack-count ,64 8 * +
        ,64
end

fn simulate-program
        0 during dup ops-count ,64 < go
                dup sizeof(Op) * ops +
                if dup Op.read(type) OP_PUSH = go
                        dup Op.read(operand) sim-stack-push
                elif dup Op.read(type) OP_PLUS = go
                        sim-stack-pop sim-stack-pop +
                        sim-stack-push
                elif dup Op.read(type) OP_MINUS = go
                        sim-stack-pop sim-stack-pop <> -
                        sim-stack-push
                elif dup Op.read(type) OP_MUL = go
                        sim-stack-pop sim-stack-pop *
                        sim-stack-push
                elif dup Op.read(type) OP_DUMP = go
                        sim-stack-pop dump
                else
                        error "unknown opration unreachable" eputs
                end _ 
                1 +
        end _
end

fn compile-program
        "[bits 64] \n" puts
        "section .text \n" puts
        ";    -- dump function -- \n" puts
        "dump: \n" puts
        "    sub rsp, 40 \n" puts
        "    mov ecx, 1 \n" puts
        "    mov r8d, 10 \n" puts
        "    mov BYTE [rsp+31], 10 \n" puts
        "    mov rsi, rsp \n" puts
        "    lea r10, [rsp+31] \n" puts
        ".L2: \n" puts
        "    mov rax, rdi \n" puts
        "    xor edx, edx \n" puts
        "    mov r9, r10 \n" puts
        "    div r8 \n" puts
        "    sub r9, rcx \n" puts
        "    inc rcx \n" puts
        "    add edx, 48 \n" puts
        "    mov BYTE [r9], dl \n" puts
        "    mov rdx, rdi \n" puts
        "    mov rdi, rax \n" puts
        "    cmp rdx, 9 \n" puts
        "    ja  .L2 \n" puts
        "    sub rsi, rcx \n" puts
        "    mov rdx, rcx \n" puts
        "    mov edi, 1 \n" puts
        "    add rsi, 32 \n" puts
        "    mov rax, 1 \n" puts
        "    syscall \n" puts
        "    add rsp, 40 \n" puts
        "    ret \n" puts
        " \n" puts
        "global _start \n" puts
        "_start: \n" puts
        "    mov [argv], rsp\n" puts
        0 during dup ops-count ,64 < go
                dup sizeof(Op) * ops +
                if dup Op.read(type) OP_PUSH = go
                        ";   -- push " puts dup Op.read(operand) putd " --\n" puts
                        "    mov rax, " puts dup Op.read(operand) putd "\n" puts
                        "    push rax\n" puts
                elif dup Op.read(type) OP_PLUS = go
                        ";   -- plus --\n" puts
                        "    pop rax\n" puts
                        "    pop rbx\n" puts
                        "    add rax, rbx\n" puts
                        "    push rax\n" puts
                elif dup Op.read(type) OP_MINUS = go
                        ";   -- minus --\n" puts
                        "    pop rax\n" puts
                        "    pop rbx\n" puts
                        "    sub rbx, rax\n" puts
                        "    push rbx\n" puts
                elif dup Op.read(type) OP_MUL = go
                        ";   -- mul --\n" puts
                        "    pop rax\n" puts
                        "    pop rbx\n" puts
                        "    mul rbx\n" puts
                        "    push rax\n" puts
                elif dup Op.read(type) OP_DUMP = go
                        ";   -- dump --\n" puts
                        "    pop rdi\n" puts
                        "    call dump\n" puts
                else
                        error "unknown opration unreachable" eputs
                end _ 
                1 +
        end _
        "\n" puts
        "    mov rdi, 0\n" puts
        "    mov rax, 60\n" puts
        "    syscall\n" puts
        "\n" puts
        "section .bss\n" puts
        "    rmem resb " puts MEM_CAPACITY putd "\n" puts
        "    argv resq 1\n" puts
end

fn usage
    "USAGE : " puts #v ,64 @ptr dup cstrlen <> puts " [OPTION] <SUBCOMMAND> [ARGS]\n" puts
    "\n" puts
    "\n" puts
    "OPTION\n" puts
    "    -I <directory> x add one include directory to include directory list\n" puts
    "    -l <limit>     x set macro depth limit to n (default=1000)\n" puts
    "    -u             x disable type checking\n" puts
    "    -L             x analyse your code without compiling or simulating it\n" puts
    "    -d             x add debug information\n" puts
    "\n" puts
    "\n" puts
    "SUBCOMMAND\n" puts
    "    -c [c|r|g] <file> Compile  the program\n" puts
    "    -s <file>         Simulate the program\n" puts
    "    -h                Show this help\n" puts
end

fn parse-program
        O_RDONLY                // flags
        file-path str.read(data) // file path
        AT_FDCWD                // dirfd
        openat
        if dup 0 < go
                error "file " eputs file-path str.read() eputs " does not exist" eputs
                1 exit
        end
        fd .64 
        if file-stat fd ,64 fstat 0 < go
                error "unable to determine size of file " eputs
                file-path str.read() eputs
                fd ,64 close _
                1 exit
        end

        file-map
        file-stat stat.size ,64
        str.write(count)

        0
        fd ,64
        MAP_PRIVATE
        PROT_READ
        file-map str.read(count)
        NULL mmap
        file-map <> str.write(data)

        if file-map ,64 0 < go
                error "unable to map file " eputs 2 #nv cstr-to-str eputs " to memory" eputs
                fd ,64 close _
                1 exit
        end

        file-content file-map str.copy()

        0 lineN .64

        during file-content str.empty() ! go
                line file-content '\n' str.chopDelim()
                lineN ++64

                during line str.empty() ! go
                        line ' ' str.trimLeft()
                        word line ' ' str.chopDelim()

                        if word str.read() "+" str.equals() go
                                OP_PLUS 0 push-op
                        elif word str.read() "-" str.equals() go
                                OP_MINUS 0 push-op
                        elif word str.read() "*" str.equals() go
                                OP_MUL 0 push-op
                        elif word str.read() "dump" str.equals() go
                                OP_DUMP 0 push-op
                        else
                                OP_PUSH word str.read() atoi push-op
                        end
                end
        end
end

define try-to-be-legit-but-fuck-leaks
        file-map str.read() munmap _
        fd ,64 close _
end

define start
        if #c 2 < go
                usage
                error "no subcommand provided\n" eputs
                1 exit
        end

        1 #nv

        if dup "-s"C cstreq go
                if #c 3 < go
                        usage
                        error "No input file provided" eputs
                        1 exit
                end

                file-path 2 #nv str.fromCstr()

                parse-program

                simulate-program

                try-to-be-legit-but-fuck-leaks
        elif dup "-c"C cstreq go
                if #c 3 < go
                        usage
                        error "No input file provided" eputs
                        1 exit
                end

                file-path 2 #nv str.fromCstr()

                parse-program

                compile-program

                try-to-be-legit-but-fuck-leaks
        elif dup "-h"C cstreq go
                usage
        else
                usage
                error "unknown subcommand " eputs
                dup cstr-to-str eputs
                1 exit
        end _

        EXIT_SUCCESS exit
end

start
